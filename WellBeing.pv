(* 

                **** WellBeing Data sharing protocol ****
 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
| M1  | U1 ->  I  | { N_1, Id_M, Id'_M }_pkI, { H(N_1, Id_M, Id'_M) }_skU1                |
| M2  | I  ->  S  | { N_2, U1, Id_M, QmH(Id'_M) }                                         |
| M3  | U2 ->  S  | { N_3, U1 }_pkS, { H(N_3, U1) }_skU2                                  |
| M4  | S  ->  U2 | { N_3, U1, Id_M }_pkU2, { H(N_3, U1, Id_M) }_skS                      |
| M5  | U2 ->  U1 | { N_4, Id_M }_pkU1, { H(N_4, Id_M) }_skU2,                            |
| M6  | U1 ->  S  | { N_5, Id_M }_pkS, { H(N_5, Id_M) }_skU1,                             |
| M7  | S  ->  I  | { N_6, QmH(Id'_M) }_pkI, { H(N_6, QmH(Id'_M)) }_skS                   |
| M8  | I  ->  S  | { N_6, Id'_M }_pkS, { H(N_6, Id'_M) }_skI                             |
| M9  | S  ->  U1 | { N_5, Id'_M }_pkU1, { H(N_5, Id'_M) }_skS                            |
| M10 | U1 ->  S  | { N_7, {TknU1U2, A, U2, TC}_pkS, { H(TknU1U2, A, U2, TC) }_skU1 }     |
| M11 | U1 ->  U2 | { N_4, TknU1U2}_pkU2, { H(N_4, TknU1U2) }_skU1                        |
| M12 | U2 ->  S  | { N_8, TknU1U2}_pkS, { H(N_8, TknU1U2) }_skU2                         |
| M13 | S  ->  U2 | { N_8, A}_pkU2, { H(N_8, A) }_skS                                     |
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

Id'_M = { {M}_pkU1, H(M)skU1 }, A = { {M'}_pkU2, H(M')skU1 }

*)



set ignoreTypes = false.

free c: channel.

type host.
type nonce.
type pkey.
type skey.


(* Type converter function *)
fun nonce_to_bitstring(nonce): bitstring [data,typeConverter].
fun bitstring_to_nonce(bitstring): nonce [data,typeConverter].
fun host_to_bitstring(host): bitstring [data,typeConverter].
fun bitstring_to_host(bitstring): host [data,typeConverter].


(* Public key encryption *)
fun pk(skey): pkey.
fun encrypt(bitstring, pkey): bitstring.
reduc forall x: bitstring, y: skey; decrypt(encrypt(x,pk(y)),y) = x.


(* Signatures *)
fun sign(bitstring, skey): bitstring.
reduc forall m: bitstring, k: skey; checksign(sign(m,k), pk(k)) = m.


(* Hash function *)
fun hash(bitstring): bitstring.


(* QmHash function *)
fun qmhash(bitstring): bitstring.


(* Secrecy assumptions *)
not attacker(new skU1).
not attacker(new skU2).
not attacker(new skS).
not attacker(new skI).


(* Honest host names U1, U2, S, I *)
free U1, U2, S, I: host.


(* Secret declaration *)
free wellBeingData, tokenU1U2, metaData, tempWellBeing : bitstring [private].


(* Secrecy query *)
query attacker(wellBeingData);
      attacker(tempWellBeing);
      attacker(tokenU1U2).


(* Event declarations *)
event beginMetadataUpload(host, host, nonce, bitstring).
event endMetadataUpload(host, host, nonce, bitstring).
event beginDataSharingRequestPartial(host, host, nonce, bitstring).
event endDataSharingRequestPartial(host, host, nonce, bitstring).
event beginDataSharingRequestFull(host, host, nonce, bitstring).
event endDataSharingRequestFull(host, host, nonce, bitstring).
event beginIpfDataRetrieveFromDapp(host, host, nonce, bitstring).
event endIpfDataRetrieveFromDapp(host, host, nonce, bitstring).
event beginSendTokentoDapp(host, host, nonce, bitstring).
event endSendTokentoDapp(host, host, nonce, bitstring).
event beginDataReadByRequester(host, host, bitstring).
event endDataReadByRequester(host, host, bitstring).
event beginDataFetchFromIpfsPartial(host, host, nonce, bitstring).
event endDataFetchFromIpfsPartial(host, host, nonce, bitstring).
event beginDataFetchFromIpfsFull(host, host, nonce, bitstring, bitstring).
event endDataFetchFromIpfsFull(host, host, nonce, bitstring, bitstring).

(* Event queries *)
query owner: host, ipfs: host, dataUpNonce: nonce, meta: bitstring; inj-event(endMetadataUpload(owner, ipfs, dataUpNonce, meta)) ==> inj-event(beginMetadataUpload(owner, ipfs, dataUpNonce, meta)).
query owner: host, requester: host, meta: bitstring, sharingNonce: nonce; inj-event(endDataSharingRequestPartial(owner, requester, sharingNonce, meta)) ==> inj-event(beginDataSharingRequestPartial(owner,requester, sharingNonce, meta)).
query owner: host, requester: host, meta: bitstring, sharingNonce: nonce, sharingToken: bitstring; inj-event(endDataSharingRequestFull(owner, requester, sharingNonce, sharingToken)) ==> inj-event(beginDataSharingRequestFull(owner, requester, sharingNonce, sharingToken)).
query owner: host, requester: host, sharingNonce: nonce, encWellBeingData: bitstring; inj-event(endIpfDataRetrieveFromDapp(owner, requester, sharingNonce, encWellBeingData)) ==> inj-event(beginIpfDataRetrieveFromDapp(owner, requester, sharingNonce, encWellBeingData)).
query owner: host, requester: host, sharingToken: bitstring, sharingNonce: nonce; inj-event(endSendTokentoDapp(owner, requester, sharingNonce, sharingToken)) ==> inj-event(beginSendTokentoDapp(owner, requester, sharingNonce, sharingToken)).
query owner: host, requester: host, tempWellBeingData: bitstring; inj-event(endDataReadByRequester(owner, requester, tempWellBeingData)) ==> inj-event(beginDataReadByRequester(owner, requester, tempWellBeingData)).
query dapp: host, ipfs: host, ipfsNonce: nonce, qmHash: bitstring; inj-event(endDataFetchFromIpfsPartial(dapp, ipfs, ipfsNonce, qmHash)) ==> inj-event(beginDataFetchFromIpfsPartial(dapp, ipfs, ipfsNonce, qmHash)).
query dapp: host, ipfs: host, ipfsNonce: nonce, encWellB: bitstring, encWellBHashed: bitstring; inj-event(endDataFetchFromIpfsFull(dapp, ipfs, ipfsNonce, encWellB, encWellBHashed)) ==> inj-event(beginDataFetchFromIpfsFull(dapp, ipfs, ipfsNonce, encWellB, encWellBHashed)).

query owner: host, requester: host, sharingNonce: nonce, sharingToken: bitstring, 
      dapp: host, ipfs: host, ipfsNonce: nonce, encWellB: bitstring, tempWellBeing: bitstring, 
      encWellBHashed: bitstring; event(endDataReadByRequester(owner, requester, tempWellBeing)) ==> inj-event(endDataSharingRequestFull(owner, requester, sharingNonce, sharingToken)) && 
                                                                                                    inj-event(endDataFetchFromIpfsFull(dapp, ipfs, ipfsNonce, encWellB, encWellBHashed)).



(* U1 process *)
let processU1(skU1: skey, pkS: pkey, pkU2: pkey, pkI: pkey) = 

    in (c, 
            (
                xI: host, 
                xU2: host
            )
        );
	if (xI = I) && (xU2 = U2) then
	let pkU1 = pk(skU1) in

    (* M1 *)
    if xI = I then 
    new N1: nonce;
    event beginMetadataUpload(U1, xI, N1, metaData);
    out (c,  
            (
                encrypt((host_to_bitstring(U1), nonce_to_bitstring(N1), metaData, encrypt(wellBeingData, pkU1), sign(hash(wellBeingData), skU1)), pkI),
                sign(hash((host_to_bitstring(U1), nonce_to_bitstring(N1), metaData, encrypt(wellBeingData, pkU1), sign(hash(wellBeingData), skU1))), skU1)
            )
        );
    
    (* M5 *)
    in (c, 
            (
                encMetaData: bitstring, 
                signedMetaData: bitstring
            )
        );
    let (u1IdMetadataSignedHash: bitstring) = checksign(signedMetaData, pkU2) in
    let(encN4:bitstring, encDecMetaData:bitstring) = decrypt(encMetaData, skU1) in
    if (u1IdMetadataSignedHash = hash((encN4, encDecMetaData))) then
    
    (* M6 *)
    new N5: nonce;
    event beginIpfDataRetrieveFromDapp(U1, xU2, N5, encrypt(wellBeingData, pkU1));
    out (c, 
            (
                encrypt((nonce_to_bitstring(N5), metaData), pkS), 
                sign(hash((nonce_to_bitstring(N5), metaData)), skU1)
            )
        );
    
    (* M9 *)
    in (c, 
            (
                recEncMetaData: bitstring, 
                recSignHashedWellBeing: bitstring
            )
        );
    let(signedHashedWellBeing: bitstring) = checksign(recSignHashedWellBeing, pkS) in
    let(xN5Enc: bitstring, xEncWellbeing: bitstring, xSignedHashedWellBeing: bitstring) = decrypt(recEncMetaData, skU1) in
    if (hash((xN5Enc, xEncWellbeing, xSignedHashedWellBeing))=signedHashedWellBeing) then
    if nonce_to_bitstring(N5) = xN5Enc then
    let (=wellBeingData) = decrypt(xEncWellbeing, skU1) in
    let hashedWellbeing = checksign(xSignedHashedWellBeing, pkU1) in
    if hash(wellBeingData) = hashedWellbeing then
    
    (* M10 *)
    new tc: bitstring;
    new N7: nonce;
    event beginDataReadByRequester(U1, U2, tempWellBeing);
    out (c, 
            (   nonce_to_bitstring(N7),
                encrypt((tokenU1U2, encrypt(tempWellBeing, pkU2), sign(hash(tempWellBeing), skU1), host_to_bitstring(U2), tc), pkS),
                sign(hash((tokenU1U2, encrypt(tempWellBeing, pkU2), sign(hash(tempWellBeing), skU1), host_to_bitstring(U2), tc)), skU1)
            )
        );
    
    (* M11 *)
    event endDataSharingRequestPartial(U1, xU2, bitstring_to_nonce(encN4), metaData);
    event beginDataSharingRequestFull(U1, xU2, bitstring_to_nonce(encN4), tokenU1U2);
    out (c, 
            (
                encrypt((encN4, tokenU1U2), pkU2), 
                sign(hash((encN4, tokenU1U2)), skU1)
            )
        );
    0.



(* U2 process *)
let processU2(skU2: skey, pkS: pkey, pkU1: pkey) = 

    in (c, 
            (
                xU1: host, 
                xS: host
            )
        );
	if (xU1 = U1) && (xS = S) then
	let pkU2 = pk(skU2) in

    (* M3 *)
    new N3: nonce;
    out (c, 
            (
                encrypt((nonce_to_bitstring(N3), host_to_bitstring(U1)), pkS), 
                sign(hash((nonce_to_bitstring(N3), host_to_bitstring(U1))), skU2)
            )
        );

    (* M4 *)
    in (c, 
            (
                encIdMeta: bitstring, 
                signedIdMeta: bitstring
            )
        );
    let (hashU1Metadata: bitstring) = checksign(signedIdMeta, pkS) in
    let (xEncN3:bitstring, u1SignString: bitstring, =metaData) = decrypt(encIdMeta, skU2) in

    if (hash((xEncN3, u1SignString, metaData)) = hashU1Metadata) then
    if nonce_to_bitstring(N3) = xEncN3 then
    let (xHostU1) = bitstring_to_host(u1SignString) in
    if xHostU1=U1 then

    (* M5 *)
    new N4: nonce;
    event beginDataSharingRequestPartial(xU1, U2, N4, metaData);
    out(c, 
            (
                encrypt((nonce_to_bitstring(N4), metaData), pkU1), 
                sign(hash((nonce_to_bitstring(N4), metaData)), skU2)
            )
        );

    (* M11 *)
    in (c, 
            (
                xU1EncRes: bitstring, 
                xU1SignRes: bitstring
            )
        );
    let (hashOfM11: bitstring) = checksign(xU1SignRes, pkU1) in
    let (xN4enc: bitstring, =tokenU1U2) = decrypt(xU1EncRes, skU2) in
    if hashOfM11=hash((xN4enc, tokenU1U2)) then 
    if xN4enc = nonce_to_bitstring(N4) then
    event endDataSharingRequestFull(xU1, U2, bitstring_to_nonce(xN4enc), tokenU1U2);
    
    (* M12 *)
    new N8: nonce;
    event beginSendTokentoDapp(xU1, U2, N8, tokenU1U2);
    out (c, 
            (
                encrypt((nonce_to_bitstring(N8), tokenU1U2, host_to_bitstring(U2)), pkS), 
                sign(hash((nonce_to_bitstring(N8), tokenU1U2, host_to_bitstring(U2))), skU2)
            )
        );

    (* M13 *)
    in (c, 
            (
                serverResEnc: bitstring, 
                serverResSign: bitstring
            )
        );
    let (tempDataHashFromSign: bitstring ) = checksign(serverResSign, pkS) in
    let (xN8Mes: bitstring, tempDataEncFromMes: bitstring, tempDataHashFromMes: bitstring ) = decrypt(serverResEnc, skU2) in

    if (tempDataHashFromSign = hash((xN8Mes, tempDataEncFromMes, tempDataHashFromMes))) then
    if (xN8Mes = nonce_to_bitstring(N8)) then
    let (=tempWellBeing) = decrypt(tempDataEncFromMes, skU2) in
    if hash(tempWellBeing) = tempDataHashFromMes then
    event endDataReadByRequester(U1, U2, tempWellBeing);
    0.



(* I process *)
let processI(pkS: pkey, skI: skey, pkU1: pkey) = 

    (* M1 *)
    in (c, 
            (
                metaDataFromU1Enc: bitstring, 
                metaDataFromU1Sign: bitstring
            )
        );
    let (xU1AsString: bitstring, xN1String: bitstring, =metaData, encWellbeing: bitstring, hashedWellBeingSigned: bitstring) = decrypt(metaDataFromU1Enc, skI) in
    let (metaDecFromU1Sign: bitstring) = checksign(metaDataFromU1Sign, pkU1) in
    if (metaDecFromU1Sign = hash((xU1AsString, xN1String, metaData, encWellbeing, hashedWellBeingSigned))) then
	if bitstring_to_host(xU1AsString) = U1 then
    let pkI = pk(skI) in
    
    (* M2 *)
    let qmHashData = qmhash((encWellbeing, hashedWellBeingSigned)) in
    new N2: nonce;
    out (c, 
            (
                nonce_to_bitstring(N2), bitstring_to_host(xU1AsString), metaData, qmHashData
            )
        );
    event endMetadataUpload(bitstring_to_host(xU1AsString), I, bitstring_to_nonce(xN1String), metaData);

    (* M7 *)
    in (c, 
            (
                recQmHashDataEnc: bitstring, 
                recQmHashDataSign: bitstring
            )
        );
    let (qmHashDataSign: bitstring) = checksign(recQmHashDataSign, pkS) in
    let (xN6enc: bitstring, qmHashDataEnc: bitstring) = decrypt(recQmHashDataEnc, skI) in
    if (qmHashDataSign = hash((xN6enc, qmHashDataEnc))) then
    event endDataFetchFromIpfsPartial(S, I, bitstring_to_nonce(xN6enc), qmHashDataSign);

    (* M8 *)
    event beginDataFetchFromIpfsFull(S, I, bitstring_to_nonce(xN6enc), encWellbeing, hashedWellBeingSigned);
    out (c, 
            (
                encrypt((xN6enc, encWellbeing, hashedWellBeingSigned), pkS), 
                sign((hash((xN6enc, encWellbeing, hashedWellBeingSigned))), skI)
            )
        );
    0.



(* S process *)
let processS(skS: skey, pkU1: pkey, pkU2: pkey, pkI: pkey) = 

    (* M2 *)
    in (c, 
            (
                xN2String: bitstring, 
                xU1: host, 
                =metaData, 
                qmHashRec: bitstring
            )
        );
	if (xU1 = U1) then
    let pkS = pk(skS) in

    (* M3 *)
    in (c, 
            (
                encU1Identity: bitstring, 
                signU1Identity: bitstring
            )
        );
    let (signedHashU1Id: bitstring) = checksign(signU1Identity, pkU2) in
    let (xN3Enc:bitstring, encU1Host:bitstring) = decrypt(encU1Identity, skS) in
    if (hash((xN3Enc, encU1Host)) = signedHashU1Id) then

    (* M4 *)
    out (c, 
            (
                encrypt((xN3Enc, encU1Host, metaData),pkU2), 
                sign(hash((xN3Enc, encU1Host, metaData)), skS)
            )
        );

    (* M6 *) 
    in (c, 
            (
                encU1Meta: bitstring, 
                signU1Meta: bitstring
            )
        );
    let (signedHashU1Metadata: bitstring) = checksign(signU1Meta, pkU1) in
    let (xN5Enc: bitstring, =metaData) = decrypt(signU1Meta, skS) in
    if (signedHashU1Metadata = hash((xN5Enc, metaData))) then
    
    (* M7 *) 
    new N6: nonce;
    event beginDataFetchFromIpfsPartial(S, I, N6, qmHashRec);
    out (c, 
            (
                encrypt((nonce_to_bitstring(N6), qmHashRec), pkI), 
                sign(hash((nonce_to_bitstring(N6), qmHashRec)), skS)
            )
        );

    (* M8 *) 
    in (c, 
            (
                encHashedWellBeingData: bitstring, 
                signHashedWellBeingData: bitstring
            )
        );
    let(signWellBeingHashed: bitstring) = checksign(signHashedWellBeingData, pkI) in
    let(xN6Enc: bitstring, encWellBeing: bitstring, encWellBeingHashed: bitstring) = decrypt(signHashedWellBeingData, skS) in
    if (hash((xN6Enc, encWellBeing, encWellBeingHashed))=signWellBeingHashed) then
    if nonce_to_bitstring(N6) = xN6Enc then
    event endDataFetchFromIpfsFull(S, I, bitstring_to_nonce(xN6Enc), encWellBeing, encWellBeingHashed);
    
    (* M9 *) 
    event endIpfDataRetrieveFromDapp(U1, U2, bitstring_to_nonce(xN5Enc), encWellBeing);
    out (c, 
            (
                encrypt((xN5Enc, encWellBeing, encWellBeingHashed), pkU1), 
                sign(hash((xN5Enc, encWellBeing, encWellBeingHashed)), skS)
            )
        );

    (* M10 *) 
    in (c, 
            (
                xN7String: bitstring, 
                tokenU1U2Enc: bitstring, 
                tokenU1U2Sign: bitstring
            )
        );
    let(hashTokenEncData: bitstring) = checksign(tokenU1U2Sign, pkU1) in
    let(=tokenU1U2, encTempMetadataSign: bitstring, encHashTempDataSign: bitstring, u2AsStringSign: bitstring, tcSign: bitstring) = decrypt(tokenU1U2Sign, skS) in
    if(hash((tokenU1U2, encTempMetadataSign, encHashTempDataSign, u2AsStringSign, tcSign)) = hashTokenEncData) then
    
    (* M12 *) 
    in (c, 
            (
                tokenSentByU2Enc: bitstring,
                tokenSentByU2Sign: bitstring
            )
        );
    let(signedHashTokenU2: bitstring) = checksign(tokenSentByU2Sign, pkU2) in
    let(xN8Mes: bitstring, =tokenU1U2, hostU2AsString: bitstring) = decrypt(tokenSentByU2Enc, skS) in
    if(hash((xN8Mes, tokenU1U2))=signedHashTokenU2) && (u2AsStringSign = hostU2AsString) then

   (* M13 *) 
    out (c, 
            (
                encrypt((xN8Mes, encTempMetadataSign, encHashTempDataSign), pkU2), 
                sign(hash((xN8Mes, encTempMetadataSign, encHashTempDataSign)), skS)
            )
        );
    event endSendTokentoDapp(U1, U2, bitstring_to_nonce(xN8Mes), tokenU1U2);
    0.


(* Main process setup *)
process 
    new skU1: skey; 
	let pkU1 = pk(skU1) in
        out(c, pkU1);
    new skU2: skey; 
	let pkU2 = pk(skU2) in
        out(c, pkU2);
	new skS: skey; 
	let pkS = pk(skS) in
	    out(c, pkS);
    new skI: skey; 
	let pkI = pk(skI) in
	    out(c, pkI);
	(
          (* Launch an unbounded number of sessions of the data owner *)
          (!processU1(skU1, pkS, pkU2, pkI)) | 
          
          (* Launch an unbounded number of sessions of the data requester *)
          (!processU2(skU2, pkS, pkU1)) |
          
          (* Launch an unbounded number of sessions of the IPFS node *)
          (!processI(pkS, skI, pkU1)) |
          
          (* Launch an unbounded number of sessions of the DApp node without IPFS *)
	      (!processS(skS, pkU1, pkU2, pkI))
    )
