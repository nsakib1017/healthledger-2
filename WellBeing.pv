(* 
                **** WellBeing Data sharing protocol ****
 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ __ _ _ _ _ _ 
|                                                                                                       |
|    M1  | U1 ->  I  | { N_1, U1, Id_M, Id'_M }_pkI, { H(N_1, Id_M, Id'_M) }_skU1                       |
|    M2  | I  ->  S  | { N_2, U1, I, Id_M, QmH(Id'_M) }_pkS, { H(N_1, Id_M, Id'_M) }_skI                |  
|    M3  | S  ->  I  | { N_2, U1, S }_pkI, { H(N_2, U1, S) }_skS                                        |                           
|    M4  | I  ->  U1 | { N_1, I }_pkU1, { N_1, I }_skI                                                  |                                
|    M5  | U2 ->  S  | { N_3, U1 }_pkS, { H(N_3, U1) }_skU2                                             |
|    M6  | S  ->  U2 | { N_3, U1, Id_M }_pkU2, { H(N_3, U1, Id_M) }_skS                                 |
|    M7  | U2 ->  U1 | { N_4, Id_M, U2 }_pkU1, { H(N_4, Id_M, U2) }_skU2,                               |
|    M8  | U1 ->  S  | { N_5, Id_M, U1, U2 }_pkS, { H(N_5, Id_M, U1, U2) }_skU1,                        |
|    M9  | S  ->  I  | { N_6, QmH(Id'_M), S, U1, U2 }_pkI, { H(N_6, QmH(Id'_M), S, U1, U2)}_skS         |
|    M10 | I  ->  S  | { N_6, Id'_M, I, U1, U2 }_pkS, { H(N_6, Id'_M, I, U1, U2) }_skI                  |
|    M11 | S  ->  U1 | { N_5, Id'_M, S }_pkU1, { H(N_5, Id'_M, S) }_skS                                 |
|    M12 | U1 ->  S  | { N_7, TknU1U2, A, U1, U2, TC}_pkS, { H(N_7, TknU1U2, A, U1, U2, TC) }_skU1 }    |
|    M13 | S ->  U1  | { N_7, TknU1U2, S, U2}_pkU1, { H(N_7, TknU1U2, S, U2) }_skS }                    |
|    M14 | U1 ->  U2 | { N_4, TknU1U2, U1}_pkU2, { H(N_4, TknU1U2, U1) }_skU1                           |
|    M15 | U2 ->  S  | { N_8, TknU1U2, U1}_pkS, { H(N_8, TknU1U2, U1) }_skU2                            |
|    M16 | S  ->  U2 | { N_8, A}_pkU2, { H(N_8, A) }_skS                                                |
 __ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ __

Id'_M = { {M}_pkU1, H(M)skU1 }, A = { {M'}_pkU2, H(M')skU1 }

*)



set ignoreTypes = false.
(* set traceDisplay = long. *)

free c: channel.

type host.
type nonce.
type pkey.
type skey.


(* Type converter function *)
fun nonce_to_bitstring(nonce): bitstring [data,typeConverter].
fun bitstring_to_nonce(bitstring): nonce [data,typeConverter].
fun host_to_bitstring(host): bitstring [data,typeConverter].
fun bitstring_to_host(bitstring): host [data,typeConverter].


(* Public key encryption *)
fun pk(skey): pkey.
fun encrypt(bitstring, pkey): bitstring.
reduc forall x: bitstring, y: skey; decrypt(encrypt(x,pk(y)),y) = x.


(* Signatures *)
fun sign(bitstring, skey): bitstring.
reduc forall m: bitstring, k: skey; checksign(sign(m,k), pk(k)) = m.


(* Hash function *)
fun hash(bitstring): bitstring.


(* QmHash function *)
fun qmhash(bitstring): bitstring.


(* Secret keys *)
const skU1:skey [private].
const skU2:skey [private].
const skS:skey [private].
const skI:skey [private].


(* Secrecy assumptions *)
not attacker(skU1).
not attacker(skU2).
not attacker(skS).
not attacker(skI).


(* Honest host names U1, U2, S, I *)
free U1, U2, S, I: host.


(* Secret declaration *)
free wellBeingData, tokenU1U2, metaData, tempWellBeing : bitstring [private].


(* Secrecy query *)
query attacker(wellBeingData);
      attacker(tempWellBeing);
      attacker(tokenU1U2).


(* Event declarations *)
event beginMetadataUpload(host, host, nonce, bitstring).
event endMetadataUpload(host, host, nonce, bitstring).
event beginDataSharingRequest(host, bitstring).
event endDataSharingRequest(host, host, bitstring).
event beginDataReadByRequester(host, host, bitstring).
event endDataReadByRequester(host, host, bitstring).


(* Event execution queries *)
query owner: host, ipfs: host, nonce: nonce, meta: bitstring; event(beginMetadataUpload(owner, ipfs, nonce, meta)).
query owner: host, ipfs: host, nonce: nonce, meta: bitstring; event(endMetadataUpload(owner, ipfs, nonce, meta)).
query owner: host, requester: host, meta: bitstring, token: bitstring; event(endDataSharingRequest(owner, requester, token)).
query requester: host, meta: bitstring, sharingNonce: nonce; event(beginDataSharingRequest(requester, meta)).
query owner: host, requester: host, tempWellBeingData: bitstring; event(beginDataReadByRequester(owner, requester, tempWellBeingData)).
query owner: host, requester: host, tempWellBeingData: bitstring; event(endDataReadByRequester(owner, requester, tempWellBeingData)).


(* Correspondence Queries *)
query owner: host, ipfs: host, nonce: nonce, meta: bitstring; event(endMetadataUpload(owner, ipfs, nonce, meta)) ==> inj-event(beginMetadataUpload(owner, ipfs, nonce, meta)).
query owner: host, requester: host, meta: bitstring, token: bitstring; inj-event(endDataSharingRequest(owner, requester, token)) ==> inj-event(beginDataSharingRequest(requester, meta)).
query owner: host, requester: host, tempWellBeingData: bitstring; inj-event(endDataReadByRequester(owner, requester, tempWellBeingData)) ==> inj-event(beginDataReadByRequester(owner, requester, tempWellBeingData)).

(* U1 process *)
let processU1(skU1: skey, pkS: pkey, pkU2: pkey, pkI: pkey) = 

    in (c, 
            (
                xI: host, 
                xU2: host
            )
        );
	if (xI = I) && (xU2 = U2) then
	let pkU1 = pk(skU1) in

    (* M1 *)
    if xI = I then 
    new N1: nonce;
    out (c,  
            (
                encrypt((N1, U1, metaData, encrypt(wellBeingData, pkU1), sign(hash(wellBeingData), skU1)), pkI),
                sign(hash((nonce_to_bitstring(N1), host_to_bitstring(U1), metaData, encrypt(wellBeingData, pkU1), sign(hash(wellBeingData), skU1))), skU1)
            )
        );

    (* M4_ *)
    in (c, 
            (
                encM4: bitstring, 
                encSigM4: bitstring
            )
        );
    let (=N1, =I) = decrypt(encM4, skU1) in
    let (sigM4: bitstring) = checksign(encSigM4, pkI) in
    if sigM4 = hash((nonce_to_bitstring(N1), host_to_bitstring(I))) then event endMetadataUpload(U1, I, N1, metaData);
    
    (* M5 *)
    in (c, 
            (
                encMetaData: bitstring, 
                signedMetaData: bitstring
            )
        );
    let (u1IdMetadataSignedHash: bitstring) = checksign(signedMetaData, pkU2) in
    let(encN4: nonce, =U2, =metaData) = decrypt(encMetaData, skU1) in
    if (u1IdMetadataSignedHash = hash((nonce_to_bitstring(encN4), host_to_bitstring(U2), metaData))) then event beginDataSharingRequest(U2, metaData);

    (* M6 *)
    new N5: nonce;
    out (c, 
            (
                encrypt((nonce_to_bitstring(N5), metaData), pkS), 
                sign(hash((nonce_to_bitstring(N5), metaData)), skU1)
            )
        );
    
    (* M9 *)
    in (c, 
            (
                recEncMetaData: bitstring, 
                recSignHashedWellBeing: bitstring
            )
        );
    let(signedHashedWellBeing: bitstring) = checksign(recSignHashedWellBeing, pkS) in
    let(xN5Enc: bitstring, xEncWellbeing: bitstring, xSignedHashedWellBeing: bitstring) = decrypt(recEncMetaData, skU1) in
    if (signedHashedWellBeing=hash((xN5Enc, xEncWellbeing, xSignedHashedWellBeing))) then
    if xN5Enc = nonce_to_bitstring(N5) then
    let (=wellBeingData) = decrypt(xEncWellbeing, skU1) in
    let hashedWellbeing = checksign(xSignedHashedWellBeing, pkU1) in
    if hashedWellbeing = hash(wellBeingData) then
    event beginDataReadByRequester(U1, U2, tempWellBeing);
    
    (* M10 *)
    new tc: bitstring;
    new N7: nonce;
    out (c, 
            (  
                encrypt((N7, tokenU1U2, encrypt(tempWellBeing, pkU2), sign(hash(tempWellBeing), skU1), host_to_bitstring(U2), tc), pkS),
                sign(hash((nonce_to_bitstring(N7), tokenU1U2, encrypt(tempWellBeing, pkU2), sign(hash(tempWellBeing), skU1), host_to_bitstring(U2), tc)), skU1)
            )
        );

    in (c, 
            (
                encServTokRcvMsg: bitstring,
                sigServTokRcvMsg: bitstring
            )
       );
    let (=N7, =tokenU1U2, =U2) = decrypt(encServTokRcvMsg, skU1) in
    let (sigServMsg: bitstring) = checksign(sigServTokRcvMsg, pkS) in
    if sigServMsg = hash((nonce_to_bitstring(N7), tokenU1U2, host_to_bitstring(U2))) then
    
    (* M11 *)
    out (c, 
            (
                encrypt((encN4, tokenU1U2), pkU2), 
                sign(hash((nonce_to_bitstring(encN4), tokenU1U2)), skU1)
            )
        );
    0.



(* U2 process *)
let processU2(skU2: skey, pkS: pkey, pkU1: pkey) = 

    in (c, 
            (
                xU1: host, 
                xS: host
            )
        );
	if (xU1 = U1) && (xS = S) then
	let pkU2 = pk(skU2) in

    (* M5_ *)
    new N3: nonce;
    out (c, 
            (
                encrypt((N3, U1), pkS), 
                sign(hash((nonce_to_bitstring(N3), host_to_bitstring(U1))), skU2)
            )
        );

    (* M6_ *)
    in (c, 
            (
                encM6: bitstring, 
                encSigM6: bitstring
            )
        );
    let (sigM6: bitstring) = checksign(encSigM6, pkS) in
    let (=N3, =U1, =metaData) = decrypt(encM6, skU2) in
    if (sigM6 = hash((nonce_to_bitstring(N3), host_to_bitstring(U1), metaData))) then

    (* M7_ *)
    new N4: nonce;
    out(c, 
            (
                encrypt((N4, U2, metaData), pkU1), 
                sign(hash((nonce_to_bitstring(N4), host_to_bitstring(U2), metaData)), skU2)
            )
        );

    (* M11 *)
    in (c, 
            (
                xU1EncRes: bitstring, 
                xU1SignRes: bitstring
            )
        );
    let (hashOfM11: bitstring) = checksign(xU1SignRes, pkU1) in
    let (=N4, =tokenU1U2) = decrypt(xU1EncRes, skU2) in
    if (hashOfM11=hash((nonce_to_bitstring(N4), tokenU1U2))) then
    event endDataSharingRequest(U1, U2, tokenU1U2);

    (* M12 *)
    new N8: nonce;
    out (c, 
            (
                encrypt((nonce_to_bitstring(N8), tokenU1U2, host_to_bitstring(U2)), pkS), 
                sign(hash((nonce_to_bitstring(N8), tokenU1U2, host_to_bitstring(U2))), skU2)
            )
        );

    (* M13 *)
    in (c, 
            (
                serverResEnc: bitstring, 
                serverResSign: bitstring
            )
        );
    let (tempDataHashFromSign: bitstring ) = checksign(serverResSign, pkS) in
    let (xN8Mes: bitstring, tempDataEncFromMes: bitstring, tempDataHashFromMes: bitstring ) = decrypt(serverResEnc, skU2) in

    if (tempDataHashFromSign = hash((xN8Mes, tempDataEncFromMes, tempDataHashFromMes))) then
    if (xN8Mes = nonce_to_bitstring(N8)) then
    let (=tempWellBeing) = decrypt(tempDataEncFromMes, skU2) in
    let (decTempDataSigned: bitstring) = checksign(tempDataHashFromMes, pkU1) in
    if decTempDataSigned = hash(tempWellBeing) then event endDataReadByRequester(U1, U2, tempWellBeing);
    0.



(* I process *)
let processI(pkS: pkey, skI: skey, pkU1: pkey) = 

    (* M1 *)
    in (c, 
            (
                encM1: bitstring, 
                encSigM1: bitstring
            )
        );
    let (xN1: nonce, =U1, =metaData, encWellbeing: bitstring, hashedWellBeingSigned: bitstring) = decrypt(encM1, skI) in
    let (sigM1: bitstring) = checksign(encSigM1, pkU1) in
    if (sigM1 = hash((nonce_to_bitstring(xN1), host_to_bitstring(U1), metaData, encWellbeing, hashedWellBeingSigned))) then
    let pkI = pk(skI) in
    
    (* M2 *)
    let qmHashData = qmhash((encWellbeing, hashedWellBeingSigned)) in
    event beginMetadataUpload(U1, I, xN1, metaData);
    new N2: nonce;
    out (c, 
            (
               encrypt((N2, U1, I, metaData, qmHashData), pkS),
               sign(hash((nonce_to_bitstring(N2), host_to_bitstring(U1), host_to_bitstring(I), metaData, qmHashData)), skI)
            )
        );

    (* M3_ *)   
    in (c, 
            (
                encM3: bitstring,
                encSigM3: bitstring
            )
       );  
    let (=N2, =U1, =S) = decrypt(encM3, skI) in
    let (sigM3: bitstring) = checksign(encSigM3, pkS) in
    if sigM3 = hash((nonce_to_bitstring(N2), host_to_bitstring(U1), host_to_bitstring(S))) then

    (* M4_ *)
    out (c, 
            (
                encrypt((xN1, I), pkU1),
                sign(hash((nonce_to_bitstring(xN1), host_to_bitstring(I))), skI)
            )
        );

    (* M7 *)
    in (c, 
            (
                recQmHashDataEnc: bitstring, 
                recQmHashDataSign: bitstring
            )
        );
    let (qmHashDataSign: bitstring) = checksign(recQmHashDataSign, pkS) in
    let (xN6enc: bitstring, qmHashDataEnc: bitstring) = decrypt(recQmHashDataEnc, skI) in
    if (qmHashDataSign = hash((xN6enc, qmHashDataEnc))) then

    (* M8 *)
    out (c, 
            (
                encrypt((xN6enc, encWellbeing, hashedWellBeingSigned), pkS), 
                sign((hash((xN6enc, encWellbeing, hashedWellBeingSigned))), skI)
            )
        );
    0.



(* S process *)
let processS(skS: skey, pkU1: pkey, pkU2: pkey, pkI: pkey) = 

    (* M2 *)
    in (c, 
            (
                encM1: bitstring, 
                encSigM1: bitstring
            )
        );
    let (xN2: nonce, =U1, =I, =metaData, xQmHashData: bitstring) = decrypt(encM1, skS) in
    let (sigM1: bitstring) = checksign(encSigM1, pkI) in
    if (sigM1 = hash((nonce_to_bitstring(xN2), host_to_bitstring(U1), host_to_bitstring(I), metaData, xQmHashData))) then 

    (* M3_ *)
    out (c,
            (
                encrypt((xN2, U1, S), pkI),
                sign(hash((nonce_to_bitstring(xN2), host_to_bitstring(U1), host_to_bitstring(S))), skS)
            )
        );

    let pkS = pk(skS) in

    (* M5_ *)
    in (c, 
            (
                encM5: bitstring, 
                encSigM5: bitstring
            )
        );
    let (sigM5: bitstring) = checksign(encSigM5, pkU2) in
    let (xN3:nonce, =U1) = decrypt(encM5, skS) in
    if (sigM5=hash((nonce_to_bitstring(xN3), host_to_bitstring(U1)))) then

    (* M6_ *)
    out (c, 
            (
                encrypt((xN3, U1, metaData),pkU2), 
                sign(hash((nonce_to_bitstring(xN3), host_to_bitstring(U1), metaData)), skS)
            )
        );

    (* M6 *) 
    in (c, 
            (
                encU1Meta: bitstring, 
                signU1Meta: bitstring
            )
        );
    let (signedHashU1Metadata: bitstring) = checksign(signU1Meta, pkU1) in
    let (xN5Enc: bitstring, =metaData) = decrypt(encU1Meta, skS) in
    
    if (signedHashU1Metadata = hash((xN5Enc, metaData))) then
    new N6: nonce;
    
    (* M7 *) 
    out (c, 
            (
                encrypt((nonce_to_bitstring(N6), xQmHashData), pkI), 
                sign(hash((nonce_to_bitstring(N6), xQmHashData)), skS)
            )
        );

    (* M8 *) 
    in (c, 
            (
                encHashedWellBeingData: bitstring, 
                signHashedWellBeingData: bitstring
            )
        );
    let(signWellBeingHashed: bitstring) = checksign(signHashedWellBeingData, pkI) in
    let(xN6Enc: bitstring, encWellBeing: bitstring, encWellBeingHashed: bitstring) = decrypt(encHashedWellBeingData, skS) in
    if signWellBeingHashed=hash((xN6Enc, encWellBeing, encWellBeingHashed)) then
    if xN6Enc = nonce_to_bitstring(N6) then

    (* M9 *) 
    out (c, 
            (
                encrypt((xN5Enc, encWellBeing, encWellBeingHashed), pkU1), 
                sign(hash((xN5Enc, encWellBeing, encWellBeingHashed)), skS)
            )
        );

    (* M10 *) 
    in (c, 
            (
                tokenU1U2Enc: bitstring, 
                tokenU1U2Sign: bitstring
            )
        );
    let(hashTokenEncData: bitstring) = checksign(tokenU1U2Sign, pkU1) in
    let(xN7: nonce, =tokenU1U2, encTempMetadataSign: bitstring, encHashTempDataSign: bitstring, u2AsStringSign: bitstring, tcSign: bitstring) = decrypt(tokenU1U2Enc, skS) in  
    if(hashTokenEncData=hash((nonce_to_bitstring(xN7), tokenU1U2, encTempMetadataSign, encHashTempDataSign, u2AsStringSign, tcSign))) then
    
    out (c, 
            (
                encrypt((xN7, tokenU1U2, U2), pkU1),
                sign(hash((nonce_to_bitstring(xN7), tokenU1U2, host_to_bitstring(U2))), skS)
            )
        );
    
    (* M12 *) 
    in (c, 
            (
                tokenSentByU2Enc: bitstring,
                tokenSentByU2Sign: bitstring
            )
        );
    let(xN8Mes: bitstring, =tokenU1U2, hostU2AsString: bitstring) = decrypt(tokenSentByU2Enc, skS) in
    let(signedHashTokenU2: bitstring) = checksign(tokenSentByU2Sign, pkU2) in
    if(signedHashTokenU2=hash((xN8Mes, tokenU1U2, hostU2AsString))) && (u2AsStringSign = hostU2AsString) then

   (* M13 *) 
    out (c, 
            (
                encrypt((xN8Mes, encTempMetadataSign, encHashTempDataSign), pkU2), 
                sign(hash((xN8Mes, encTempMetadataSign, encHashTempDataSign)), skS)
            )
        );
    0.


(* Main process setup *)
process 
	let pkU1 = pk(skU1) in
        out(c, pkU1);
	let pkU2 = pk(skU2) in
        out(c, pkU2);
	let pkS = pk(skS) in
	    out(c, pkS);
	let pkI = pk(skI) in
	    out(c, pkI);
	(
          (* Launch an unbounded number of sessions of the data owner *)
          (!processU1(skU1, pkS, pkU2, pkI)) | 
          
          (* Launch an unbounded number of sessions of the data requester *)
          (!processU2(skU2, pkS, pkU1)) |
          
          (* Launch an unbounded number of sessions of the IPFS node *)
          (!processI(pkS, skI, pkU1)) |
          
          (* Launch an unbounded number of sessions of the DApp node without IPFS *)
	      (!processS(skS, pkU1, pkU2, pkI))
    )
